---
output:
  pdf_document: default
---

Step 1: Loading in the Data

```{r}
# Packages used in tutorials
library(MASS)      # boxcox
library(car)       # qqPlot
library(randtests) # runs.test
# library(forecast) # OPTIONAL if you want auto.arima, not required

bike <- read.csv("trips_per_day.csv")
bike$trip_date <- as.Date(bike$trip_date)

str(bike)
head(bike)
range(bike$trip_date)

```
Initial Plotting for Time Series

```{r}
# Sort just in case
bike <- bike[order(bike$trip_date), ]

# Extract response as a vector
y <- bike$n_trips

# Daily frequency with yearly seasonality (approx 365)
bike_ts <- ts(
  y,
  start = c(as.numeric(format(min(bike$trip_date), "%Y")), 
            as.numeric(format(min(bike$trip_date), "%j"))),
  frequency = 365
)

plot(bike_ts, main = "Daily BikeShare Trips in Toronto", ylab = "Trips")

```

Step 2: EDA 

```{r}
par(mfrow = c(1, 1))
plot(bike_ts, main = "Daily Trips", ylab = "Trips")

# maybe a zoom on a couple of years
plot(window(bike_ts, start = c(2019, 1), end = c(2021, 365)),
     main = "Daily Trips: 2019–2021", ylab = "Trips")

```

Confirming Seasonality with ACF and Spectrum

```{r}
acf(as.vector(bike_ts), lag.max = 400,
    main = "ACF of Daily Trips")
spec_bike <- spectrum(as.vector(bike_ts), spans = 5)
1 / spec_bike$freq[which.max(spec_bike$spec)]  # estimated period

```
Step 3: Box-Cox transformation 

```{r}
# Simple intercept-only model (like in tutorial)
bc_model_raw <- lm(bike_ts ~ 1)
boxcox_raw   <- MASS::boxcox(bc_model_raw, lambda = seq(-2, 2, 0.1))
(lambda_opt_raw <- boxcox_raw$x[which.max(boxcox_raw$y)])

```

```{r}
tim <- time(bike_ts)  # continuous time index

# Season: year and day-of-year or month; simplest is month
# Build a monthly factor from dates (instead of cycle, since this is daily)
month <- factor(format(bike$trip_date, "%m"))

reg_for_bc <- lm(bike_ts ~ tim + month)
boxcox_mod <- MASS::boxcox(reg_for_bc, lambda = seq(-2, 2, 0.1))
(lambda_opt_mod <- boxcox_mod$x[which.max(boxcox_mod$y)])

```
```{r}
lam <- lambda_opt_mod   # keep this for later

if (lam == 0) {
  y_trans <- log(bike_ts)
} else if (lam > 0) {
  y_trans <- (bike_ts^lam - 1) / lam
} else { 
  # negative lambda → use minus sign trick like in lectures
  y_trans <- -(bike_ts^lam)
}

plot(y_trans, main = "Transformed Daily Trips", ylab = "Transformed trips")

```
Classical Decomposition 
```{r}
Decomp_bike <- stl(y_trans, s.window = "periodic")
plot(Decomp_bike, main = "STL Decomposition of Transformed Daily Trips")

# Extract components if needed
bike_seasonal <- Decomp_bike$time.series[, "seasonal"]
bike_trend    <- Decomp_bike$time.series[, "trend"]
bike_remainder <- Decomp_bike$time.series[, "remainder"]

```
```{r}
tim   <- time(y_trans)
month <- factor(format(bike$trip_date, "%m"))
dow   <- factor(weekdays(bike$trip_date))  # optional, but nice

# Simple model: linear trend + monthly seasonality
reg1 <- lm(y_trans ~ tim + month)
summary(reg1)

```
```{r}
reg2 <- lm(y_trans ~ poly(tim, 2, raw = FALSE) + month)
summary(reg2)
```

```{r}
reg3 <- lm(y_trans ~ poly(tim, 2, raw = FALSE) + month + dow)
summary(reg3)
```



